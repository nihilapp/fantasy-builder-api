# 03. 사용자 관리 기능 구현하기

## 목차
1. [사용자 관리 기능 개요](#사용자-관리-기능-개요)
2. [UserEntity - 데이터베이스 구조](#userentity---데이터베이스-구조)
3. [UserVO - 데이터 전달 객체](#uservo---데이터-전달-객체)
4. [UserRepository - 데이터 접근 계층](#userrepository---데이터-접근-계층)
5. [UserService - 비즈니스 로직 계층](#userservice---비즈니스-로직-계층)
6. [UserController - API 계층](#usercontroller---api-계층)
7. [전체 흐름 정리](#전체-흐름-정리)

---

## 사용자 관리 기능 개요

사용자 관리 기능은 다음과 같은 작업을 수행합니다:
- 사용자 목록 조회 (페이징, 검색 지원)
- 사용자 상세 조회
- 회원가입 (사용자 생성)
- 사용자 정보 수정
- 회원 탈퇴 (소프트 삭제)

### 계층 구조 (Layered Architecture)

```
[Controller] ← 클라이언트 요청/응답 처리
     ↓
[Service] ← 비즈니스 로직 처리
     ↓
[Repository] ← 데이터베이스 접근
     ↓
[Entity] ← 데이터베이스 테이블
```

각 계층의 역할:
- **Controller**: HTTP 요청을 받아서 Service를 호출하고, 결과를 JSON으로 반환
- **Service**: 비즈니스 로직 처리 (검증, 변환, 트랜잭션 관리)
- **Repository**: 데이터베이스 쿼리 실행
- **Entity**: 데이터베이스 테이블과 매핑

---

## UserEntity - 데이터베이스 구조

사용자 정보를 데이터베이스에 저장하기 위한 엔티티입니다.

```java
@Entity
@Getter
@Table(name = "users", indexes = {
    @Index(name = "idx_users_user_eml", columnList = "user_eml")
})
@DynamicInsert
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class UserEntity extends CommonEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "user_no")
  private Long userNo;

  @Column(name = "user_eml")
  private String userEml;

  @Column(name = "user_nm")
  private String userNm;

  @Column(name = "user_role")
  @Enumerated(EnumType.STRING)
  private UserRoleCode userRole;

  @Column(name = "enpswd")
  private String enpswd;  // 암호화된 비밀번호

  // ... 기타 필드들
}
```

### 어노테이션 설명

#### `@Entity`
- **역할**: 이 클래스가 JPA 엔티티임을 나타냅니다
- **결과**: JPA가 이 클래스를 데이터베이스 테이블과 매핑합니다
- **필수**: 엔티티 클래스에는 반드시 필요합니다

#### `@Table(name = "users")`
- **역할**: 데이터베이스 테이블 이름을 지정합니다
- **기본값**: 클래스 이름을 소문자로 변환 (`UserEntity` → `user_entity`)
- **왜 사용하나요?**: 테이블 이름을 명시적으로 지정하여 가독성을 높입니다

#### `@Index`
- **역할**: 데이터베이스 인덱스를 생성합니다
- **예시**: `@Index(name = "idx_users_user_eml", columnList = "user_eml")`
  - `user_eml` 컬럼에 인덱스를 생성하여 검색 속도를 향상시킵니다
- **왜 사용하나요?**: 이메일로 사용자를 자주 조회하므로, 인덱스를 통해 빠르게 검색할 수 있습니다

#### `@Id`
- **역할**: 이 필드가 기본 키(Primary Key)임을 나타냅니다
- **필수**: 모든 엔티티는 반드시 하나의 `@Id` 필드가 있어야 합니다

#### `@GeneratedValue(strategy = GenerationType.IDENTITY)`
- **역할**: 기본 키 값을 자동으로 생성합니다
- **IDENTITY 전략**: 데이터베이스가 자동으로 증가하는 번호를 할당 (MySQL의 AUTO_INCREMENT, PostgreSQL의 SERIAL)
- **왜 사용하나요?**: 사용자 번호를 수동으로 지정하는 대신, 데이터베이스가 자동으로 고유한 번호를 생성합니다

#### `@Column(name = "user_no")`
- **역할**: 필드와 데이터베이스 컬럼을 매핑합니다
- **기본값**: 필드 이름을 스네이크 케이스로 변환 (`userNo` → `user_no`)
- **왜 사용하나요?**: Java는 카멜 케이스, 데이터베이스는 스네이크 케이스를 사용하므로 명시적으로 매핑합니다

#### `@Enumerated(EnumType.STRING)`
- **역할**: Enum 타입을 데이터베이스에 저장하는 방식을 지정합니다
- **STRING**: Enum의 이름을 문자열로 저장 (예: `USER`, `ADMIN`)
- **ORDINAL**: Enum의 순서를 숫자로 저장 (0, 1, 2...) - 권장하지 않음
- **왜 STRING을 사용하나요?**: 데이터베이스에서 직접 확인할 때 이해하기 쉽습니다

#### `@DynamicInsert`
- **역할**: `null`이 아닌 필드만 INSERT 쿼리에 포함시킵니다
- **효과**: 기본값이 설정된 필드는 INSERT 쿼리에서 제외되어 데이터베이스 기본값이 사용됩니다
- **예시**: `useYn`이 `"Y"`로 기본값이 설정되어 있으면, INSERT 시 이 필드를 생략해도 데이터베이스에서 `'Y'`로 저장됩니다

#### `@NoArgsConstructor(access = AccessLevel.PROTECTED)`
- **역할**: 파라미터가 없는 생성자를 생성하되, 외부에서 직접 호출하지 못하도록 제한합니다
- **PROTECTED**: 같은 패키지나 상속받은 클래스에서만 접근 가능
- **왜 사용하나요?**: 
  - JPA가 객체를 생성할 때 필요합니다
  - 하지만 외부에서 `new UserEntity()`로 직접 생성하는 것을 방지하여, 빌더 패턴이나 정적 팩토리 메서드를 통해서만 생성하도록 강제합니다

### 비즈니스 로직 메서드

Entity에는 데이터베이스 필드뿐만 아니라, 비즈니스 로직을 담은 메서드도 포함됩니다:

```java
// 비밀번호 변경
public void changePassword(String newEncryptedPassword, Long updtNo) {
  this.enpswd = newEncryptedPassword;
  this.lastPswdChgDt = LocalDateTime.now();
  this.updtNo = updtNo;
  this.updtDt = LocalDateTime.now();
}

// 로그인 성공 처리
public void recordLoginSuccess(String clientIp) {
  this.lgnFailNmtm = 0;  // 실패 횟수 초기화
  this.lastLgnDt = LocalDateTime.now();
  this.lastLgnIp = clientIp;
}

// 로그인 실패 처리
public void recordLoginFailure() {
  if (this.lgnFailNmtm == null) {
    this.lgnFailNmtm = 0;
  }
  this.lgnFailNmtm++;
}
```

- **왜 Entity에 비즈니스 로직을 넣나요?**: 
  - 데이터와 관련된 로직을 한 곳에 모아 응집도를 높입니다
  - Service에서 `user.recordLoginSuccess(ip)`처럼 자연스럽게 호출할 수 있습니다

---

## UserVO - 데이터 전달 객체

클라이언트와 서버 간 데이터를 전달하기 위한 객체입니다.

```java
@Data
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
public class UserVO extends CommonVO {

  private Long userNo;
  private String userEml;
  private String userNm;
  private UserRoleCode userRole;
  private String password;        // 요청에서 들어오는 평문 비밀번호
  private String currentPassword; // 비밀번호 변경 시 현재 비밀번호
  private String newPassword;     // 비밀번호 변경 시 새 비밀번호
  private String enpswd;          // DB에 저장된 암호화된 비밀번호

  // Entity → VO 변환 생성자
  public UserVO(UserEntity userEntity) {
    this.mapFromEntity(userEntity);
  }

  // VO → Entity 변환 메서드
  public UserEntity toEntity() {
    return UserEntity.builder()
        .userEml(this.userEml)
        .userNm(this.userNm)
        .enpswd(this.enpswd)
        .build();
  }
}
```

### 어노테이션 설명

#### `@EqualsAndHashCode(callSuper = true)`
- **역할**: 부모 클래스(`CommonVO`)의 필드도 `equals()`와 `hashCode()` 계산에 포함시킵니다
- **왜 필요한가요?**: `CommonVO`의 필드들(`useYn`, `delYn` 등)도 비교 대상에 포함되어야 합니다

#### `@ToString(callSuper = true)`
- **역할**: 부모 클래스의 필드도 `toString()`에 포함시킵니다
- **왜 필요한가요?**: 디버깅 시 모든 필드를 확인할 수 있습니다

### 변환 메서드

#### Entity → VO 변환
```java
public UserVO(UserEntity userEntity) {
  this.mapFromEntity(userEntity);
}
```
- **사용 시점**: 데이터베이스에서 조회한 Entity를 API 응답으로 변환할 때
- **예시**: `UserService.findUserById()`에서 사용

#### VO → Entity 변환
```java
public UserEntity toEntity() {
  return UserEntity.builder()
      .userEml(this.userEml)
      .userNm(this.userNm)
      .enpswd(this.enpswd)
      .build();
}
```
- **사용 시점**: 클라이언트 요청 데이터를 Entity로 변환하여 저장할 때
- **예시**: `UserService.createUser()`에서 사용

---

## UserRepository - 데이터 접근 계층

데이터베이스에 접근하여 사용자 데이터를 조회, 저장, 수정, 삭제하는 인터페이스입니다.

```java
@Repository
public interface UserRepository 
    extends JpaRepository<UserEntity, Long>, 
            JpaSpecificationExecutor<UserEntity> {

  Optional<UserEntity> findByUserEml(String userEml);
  
  Optional<UserEntity> findByUserEmlAndDelYn(String userEml, String delYn);
  
  Page<UserEntity> findByUserNmContainingAndDelYn(
      String userNm, String delYn, Pageable pageable);
}
```

### 어노테이션 설명

#### `@Repository`
- **역할**: 이 인터페이스가 데이터 접근 계층(Repository)임을 나타냅니다
- **효과**: Spring이 이 인터페이스를 스캔하여 빈으로 등록합니다
- **필수는 아님**: `JpaRepository`를 상속받으면 자동으로 인식되지만, 명시적으로 표시하는 것이 좋습니다

### 인터페이스 상속

#### `JpaRepository<UserEntity, Long>`
- **역할**: 기본적인 CRUD 메서드를 자동으로 제공합니다
- **제공 메서드**:
  - `save(entity)`: 저장 또는 수정
  - `findById(id)`: ID로 조회
  - `findAll()`: 전체 조회
  - `delete(entity)`: 삭제
  - 등등...
- **제네릭 파라미터**:
  - `UserEntity`: 엔티티 타입
  - `Long`: 기본 키 타입

#### `JpaSpecificationExecutor<UserEntity>`
- **역할**: 동적 쿼리를 생성할 수 있는 기능을 제공합니다
- **제공 메서드**:
  - `findAll(Specification, Pageable)`: 조건에 맞는 데이터를 페이징하여 조회
- **왜 사용하나요?**: 검색 조건이 다양할 때 유연하게 쿼리를 구성할 수 있습니다

### 쿼리 메서드 (Query Methods)

Spring Data JPA는 메서드 이름만으로 쿼리를 자동 생성합니다:

```java
Optional<UserEntity> findByUserEml(String userEml);
```

- **동작**: `SELECT * FROM users WHERE user_eml = ?`
- **규칙**: 
  - `findBy`: 조회 메서드
  - `UserEml`: `userEml` 필드로 검색
  - 반환 타입: `Optional<UserEntity>` (결과가 없을 수 있음)

```java
Optional<UserEntity> findByUserEmlAndDelYn(String userEml, String delYn);
```

- **동작**: `SELECT * FROM users WHERE user_eml = ? AND del_yn = ?`
- **규칙**: `And`로 여러 조건을 연결

```java
Page<UserEntity> findByUserNmContainingAndDelYn(
    String userNm, String delYn, Pageable pageable);
```

- **동작**: `SELECT * FROM users WHERE user_nm LIKE '%?%' AND del_yn = ? LIMIT ? OFFSET ?`
- **규칙**: 
  - `Containing`: `LIKE '%값%'` (부분 일치)
  - `Pageable`: 페이징 정보 (페이지 번호, 페이지 크기)
  - 반환 타입: `Page<UserEntity>` (페이징 정보 포함)

---

## UserService - 비즈니스 로직 계층

사용자 관련 비즈니스 로직을 처리하는 서비스 클래스입니다.

```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class UserService {

  private final UserRepository userRepository;
  private final PasswordHelper passwordHelper;

  // 사용자 목록 조회
  public ListType<UserVO> findUsers(UserVO searchVO, int page) {
    Pageable pageable = PageUtils.createPageable(page);
    Specification<UserEntity> spec = buildSpecification(searchVO);
    Page<UserEntity> entityPage = userRepository.findAll(spec, pageable);
    
    Page<UserVO> voPage = entityPage.map(UserVO::new);
    List<UserVO> voList = voPage.getContent();
    
    return new ListType<>(
        voList,
        voPage.getTotalElements(),
        PageUtils.DEFAULT_PAGE_SIZE,
        page,
        voPage.getTotalPages(),
        voPage.isFirst(),
        voPage.isLast()
    );
  }

  // 사용자 생성
  @Transactional
  public UserVO createUser(UserVO userVO) {
    // 이메일 중복 검증
    if (userRepository.findByUserEml(userVO.getUserEml()).isPresent()) {
      throw new BusinessException(ResponseCode.EMAIL_ALREADY_EXISTS, 
          "이미 사용 중인 이메일입니다.");
    }

    // 비밀번호 해싱
    if (userVO.getPassword() != null && !userVO.getPassword().isEmpty()) {
      userVO.setEnpswd(passwordHelper.encode(userVO.getPassword()));
    }

    UserEntity entity = userVO.toEntity();
    entity.setCrtNo(1L); // TODO: 인증 구현 후 현재 사용자 번호
    UserEntity saved = userRepository.save(entity);
    return new UserVO(saved);
  }
}
```

### 어노테이션 설명

#### `@Service`
- **역할**: 이 클래스가 비즈니스 로직을 처리하는 서비스 계층임을 나타냅니다
- **효과**: Spring이 이 클래스를 빈으로 등록하여 다른 클래스에서 주입받아 사용할 수 있습니다

#### `@RequiredArgsConstructor`
- **역할**: `final` 필드에 대한 생성자를 자동으로 생성합니다
- **효과**: 
  ```java
  // 이렇게 작성한 것과 동일:
  public UserService(UserRepository userRepository, PasswordHelper passwordHelper) {
    this.userRepository = userRepository;
    this.passwordHelper = passwordHelper;
  }
  ```
- **왜 사용하나요?**: 의존성 주입(Dependency Injection)을 간편하게 할 수 있습니다

#### `@Transactional(readOnly = true)`
- **역할**: 클래스 레벨에 트랜잭션을 적용합니다
- **`readOnly = true`**: 읽기 전용 트랜잭션 (성능 최적화)
- **효과**: 
  - 모든 메서드가 기본적으로 읽기 전용 트랜잭션으로 실행됩니다
  - 데이터를 변경하는 메서드에는 `@Transactional`을 별도로 붙여야 합니다 (기본값: `readOnly = false`)

#### `@Transactional` (메서드 레벨)
- **역할**: 이 메서드를 트랜잭션으로 실행합니다
- **효과**: 
  - 메서드가 성공하면 커밋, 예외 발생 시 롤백
  - `readOnly = false`가 기본값이므로 데이터 변경이 가능합니다

### 주요 메서드 설명

#### `findUsers()` - 목록 조회
```java
public ListType<UserVO> findUsers(UserVO searchVO, int page) {
  // 1. 페이징 정보 생성
  Pageable pageable = PageUtils.createPageable(page);
  
  // 2. 검색 조건 구성
  Specification<UserEntity> spec = buildSpecification(searchVO);
  
  // 3. 데이터베이스에서 조회
  Page<UserEntity> entityPage = userRepository.findAll(spec, pageable);
  
  // 4. Entity → VO 변환
  Page<UserVO> voPage = entityPage.map(UserVO::new);
  
  // 5. ListType으로 변환하여 반환
  return new ListType<>(...);
}
```

**흐름**:
1. 페이지 번호를 받아서 `Pageable` 객체 생성
2. 검색 조건(`searchVO`)을 `Specification`으로 변환
3. Repository를 통해 데이터베이스에서 조회
4. Entity를 VO로 변환
5. 페이징 정보를 포함한 `ListType`으로 반환

#### `createUser()` - 사용자 생성
```java
@Transactional
public UserVO createUser(UserVO userVO) {
  // 1. 이메일 중복 검증
  if (userRepository.findByUserEml(userVO.getUserEml()).isPresent()) {
    throw new BusinessException(...);
  }

  // 2. 비밀번호 해싱
  userVO.setEnpswd(passwordHelper.encode(userVO.getPassword()));

  // 3. VO → Entity 변환
  UserEntity entity = userVO.toEntity();
  entity.setCrtNo(1L);
  
  // 4. 저장
  UserEntity saved = userRepository.save(entity);
  
  // 5. Entity → VO 변환하여 반환
  return new UserVO(saved);
}
```

**흐름**:
1. 이메일 중복 확인
2. 평문 비밀번호를 해시로 변환
3. VO를 Entity로 변환
4. 데이터베이스에 저장
5. 저장된 Entity를 VO로 변환하여 반환

---

## UserController - API 계층

HTTP 요청을 받아서 Service를 호출하고, 결과를 JSON으로 반환하는 컨트롤러입니다.

```java
@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {

  private final UserService userService;

  @GetMapping
  public ResponseEntity<ApiResponse<ListType<UserVO>>> getUsers(
      @RequestParam(defaultValue = "1") int page,
      @Valid UserVO searchVO) {
    ListType<UserVO> listType = userService.findUsers(searchVO, page);
    return ResponseEntity.ok(ApiResponse.success(listType));
  }

  @GetMapping("/{userNo}")
  public ResponseEntity<ApiResponse<UserVO>> getUser(@PathVariable Long userNo) {
    UserVO userVO = userService.findUserById(userNo);
    return ResponseEntity.ok(ApiResponse.success(userVO));
  }

  @PostMapping
  public ResponseEntity<ApiResponse<UserVO>> createUser(
      @Valid @RequestBody UserVO userVO) {
    UserVO created = userService.createUser(userVO);
    return ResponseEntity.ok(ApiResponse.success(ResponseCode.CREATED, created));
  }
}
```

### 어노테이션 설명

#### `@RestController`
- **역할**: 이 클래스가 REST API 컨트롤러임을 나타냅니다
- **효과**: 
  - `@Controller` + `@ResponseBody`의 조합
  - 메서드의 반환값을 자동으로 JSON으로 변환하여 응답

#### `@RequestMapping("/users")`
- **역할**: 이 컨트롤러의 모든 엔드포인트에 공통 경로를 추가합니다
- **효과**: 모든 메서드의 URL 앞에 `/users`가 붙습니다
- **예시**: `@GetMapping` → `/users`, `@GetMapping("/{userNo}")` → `/users/{userNo}`

#### `@GetMapping`
- **역할**: HTTP GET 요청을 처리합니다
- **사용 시점**: 데이터를 조회할 때

#### `@PostMapping`
- **역할**: HTTP POST 요청을 처리합니다
- **사용 시점**: 새로운 데이터를 생성할 때

#### `@PathVariable`
- **역할**: URL 경로에서 변수를 추출합니다
- **예시**: `/users/123` → `userNo = 123`

#### `@RequestParam`
- **역할**: 쿼리 파라미터에서 값을 추출합니다
- **예시**: `/users?page=2` → `page = 2`
- **`defaultValue`**: 값이 없을 때 기본값 설정

#### `@RequestBody`
- **역할**: HTTP 요청 본문(JSON)을 객체로 변환합니다
- **예시**: `{"userEml": "test@example.com", "userNm": "홍길동"}` → `UserVO` 객체

#### `@Valid`
- **역할**: 요청 데이터의 유효성을 검증합니다
- **효과**: `UserVO`에 설정된 검증 규칙을 확인합니다 (예: `@NotNull`, `@Email` 등)
- **실패 시**: `MethodArgumentNotValidException` 발생 → `GlobalExceptionHandler`에서 처리

### 응답 구조

모든 API 응답은 `ApiResponse`로 래핑됩니다:

```java
return ResponseEntity.ok(ApiResponse.success(listType));
```

**응답 예시**:
```json
{
  "data": {
    "list": [...],
    "totalCnt": 100,
    "page": 1,
    "pageSize": 10,
    ...
  },
  "error": false,
  "code": "OK",
  "message": "성공"
}
```

---

## 전체 흐름 정리

### 사용자 목록 조회 예시

```
1. 클라이언트 요청
   GET /users?page=1&userNm=홍

2. Controller
   - @GetMapping으로 요청 받음
   - UserVO searchVO에 쿼리 파라미터 자동 바인딩
   - userService.findUsers(searchVO, 1) 호출

3. Service
   - Pageable 생성
   - Specification으로 검색 조건 구성
   - userRepository.findAll(spec, pageable) 호출

4. Repository
   - JPA가 동적 쿼리 생성 및 실행
   - SELECT * FROM users WHERE user_nm LIKE '%홍%' AND del_yn = 'N' LIMIT 10 OFFSET 0

5. 데이터베이스
   - 쿼리 실행 결과 반환

6. Repository → Service
   - Page<UserEntity> 반환

7. Service
   - Entity를 VO로 변환
   - ListType으로 래핑

8. Service → Controller
   - ListType<UserVO> 반환

9. Controller
   - ApiResponse로 래핑
   - JSON으로 변환하여 응답

10. 클라이언트 응답
    {
      "data": {
        "list": [...],
        "totalCnt": 5,
        ...
      },
      "error": false,
      "code": "OK"
    }
```

### 사용자 생성 예시

```
1. 클라이언트 요청
   POST /users
   {
     "userEml": "test@example.com",
     "userNm": "홍길동",
     "password": "Password123!"
   }

2. Controller
   - @PostMapping으로 요청 받음
   - @RequestBody로 JSON을 UserVO로 변환
   - @Valid로 유효성 검증
   - userService.createUser(userVO) 호출

3. Service
   - 이메일 중복 검증
   - 비밀번호 해싱
   - VO → Entity 변환
   - userRepository.save(entity) 호출

4. Repository
   - JPA가 INSERT 쿼리 생성 및 실행
   - INSERT INTO users (user_eml, user_nm, enpswd, ...) VALUES (...)

5. 데이터베이스
   - 레코드 저장
   - 생성된 user_no 반환

6. Repository → Service
   - 저장된 UserEntity 반환

7. Service
   - Entity → VO 변환

8. Service → Controller
   - UserVO 반환

9. Controller
   - ApiResponse로 래핑
   - JSON으로 변환하여 응답

10. 클라이언트 응답
    {
      "data": {
        "userNo": 1,
        "userEml": "test@example.com",
        "userNm": "홍길동",
        ...
      },
      "error": false,
      "code": "CREATED"
    }
```

---

## 다음 단계

이제 사용자 관리 기능을 이해했으니, **인증 시스템**이 어떻게 구현되었는지 살펴보겠습니다.

[다음: 04. 인증 시스템 구현하기](./04_인증_시스템_구현하기.md)
