# 06. 전역 풀 엔티티 구현하기

## 목차
1. [전역 풀 엔티티란?](#전역-풀-엔티티란)
2. [TraitEntity - 전역 특성 엔티티](#traitentity---전역-특성-엔티티)
3. [TraitService - 특성 비즈니스 로직](#traitservice---특성-비즈니스-로직)
4. [TraitController - 특성 API](#traitcontroller---특성-api)
5. [AbilityEntity - 전역 어빌리티 엔티티](#abilityentity---전역-어빌리티-엔티티)
6. [전체 흐름 정리](#전체-흐름-정리)

---

## 전역 풀 엔티티란?

### 개념

**전역 풀(Global Pool)**: 모든 프로젝트가 공유하는 데이터 풀

이 프로젝트는 **판타지 세계관 빌더** 애플리케이션입니다. 사용자는 여러 프로젝트를 만들 수 있고, 각 프로젝트는 독립적인 세계관을 가집니다.

**전역 풀의 역할**:
- 모든 프로젝트에서 공통으로 사용할 수 있는 특성(Trait)과 어빌리티(Ability)를 관리
- 예: "불 저항", "마법 사용", "투명화" 같은 특성은 여러 프로젝트에서 재사용 가능

### 전역 풀 vs 프로젝트 종속

| 구분 | 전역 풀 | 프로젝트 종속 |
|------|---------|---------------|
| **범위** | 모든 프로젝트 공유 | 특정 프로젝트만 사용 |
| **예시** | "불 저항" (범용) | "드래곤의 불꽃 저항" (특정 프로젝트 전용) |
| **관리** | 관리자 또는 모든 사용자 | 프로젝트 소유자만 |

### 구현된 엔티티

- **TraitEntity**: 전역 특성 (예: "불 저항", "마법 사용")
- **AbilityEntity**: 전역 어빌리티 (예: "파이어볼", "힐링")

---

## TraitEntity - 전역 특성 엔티티

특성(Trait)은 캐릭터, 아이템, 지역 등에 부여할 수 있는 속성입니다.

```java
@Entity
@Getter
@Table(name = "traits", indexes = {
    @Index(name = "idx_traits_trait_nm", columnList = "trait_nm"),
    @Index(name = "idx_traits_cnfl_trait_no", columnList = "cnfl_trait_no")
})
@DynamicInsert
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class TraitEntity extends CommonEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "trait_no")
  private Long traitNo;

  @Column(name = "trait_nm", nullable = false)
  private String traitNm;  // 특성명

  @Column(name = "trait_expln", columnDefinition = "TEXT")
  private String traitExpln;  // 특성 설명

  @Column(name = "trait_lcls")
  private String traitLcls;  // 특성 대분류

  @Column(name = "trait_mcls")
  private String traitMcls;  // 특성 중분류

  @Column(name = "aply_trgt")
  private String aplyTrgt;  // 적용 대상 (CHAR, ITEM, NATION, ORG, REGION)

  @ManyToOne
  @JoinColumn(name = "cnfl_trait_no")
  private TraitEntity cnflTrait;  // 상충 특성 (자기 참조)
}
```

### 필드 설명

#### `traitNm` - 특성명
- **예시**: "불 저항", "마법 사용", "투명화"
- **특징**: `nullable = false`로 필수 값

#### `traitExpln` - 특성 설명
- **예시**: "화염 공격에 대한 저항력을 가집니다"
- **특징**: `TEXT` 타입으로 긴 설명 저장 가능

#### `traitLcls`, `traitMcls` - 분류
- **대분류**: "저항", "능력", "약점"
- **중분류**: "원소 저항", "물리 저항"
- **용도**: 특성을 카테고리별로 분류하여 검색 및 관리 용이

#### `aplyTrgt` - 적용 대상
- **값**: `CHAR` (인물), `ITEM` (아이템), `NATION` (국가), `ORG` (조직), `REGION` (지역)
- **용도**: 어떤 종류의 엔티티에 이 특성을 부여할 수 있는지 명시

#### `cnflTrait` - 상충 특성 (자기 참조)
- **의미**: 이 특성과 동시에 가질 수 없는 특성
- **예시**: "불 저항"과 "얼음 저항"은 상충할 수 있음
- **관계**: `@ManyToOne`으로 자기 자신을 참조 (Self-Referencing)

### 자기 참조 (Self-Referencing) 관계

```java
@ManyToOne
@JoinColumn(name = "cnfl_trait_no")
private TraitEntity cnflTrait;
```

**데이터베이스 구조**:
```
traits 테이블
- trait_no (PK)
- trait_nm
- cnfl_trait_no (FK → traits.trait_no)  ← 자기 자신을 참조
```

**예시 데이터**:
```
trait_no | trait_nm    | cnfl_trait_no
---------|-------------|---------------
1        | 불 저항      | NULL
2        | 얼음 저항    | 1          ← 불 저항과 상충
3        | 물 저항      | NULL
```

**왜 사용하나요?**
- 특성 간의 관계를 표현할 수 있음
- 예: "불 저항"을 가진 캐릭터는 "얼음 저항"을 가질 수 없음

---

## TraitService - 특성 비즈니스 로직

특성 관련 비즈니스 로직을 처리하는 서비스입니다.

```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class TraitService {

  private final TraitRepository traitRepository;

  // 특성 목록 조회
  public ListType<TraitVO> findTraits(TraitVO searchVO, int page) {
    Pageable pageable = PageUtils.createPageable(page);
    Specification<TraitEntity> spec = buildSpecification(searchVO);
    Page<TraitEntity> entityPage = traitRepository.findAll(spec, pageable);

    Page<TraitVO> voPage = entityPage.map(TraitVO::new);
    List<TraitVO> voList = voPage.getContent();
    
    return new ListType<>(
        voList,
        voPage.getTotalElements(),
        PageUtils.DEFAULT_PAGE_SIZE,
        page,
        voPage.getTotalPages(),
        voPage.isFirst(),
        voPage.isLast()
    );
  }

  // 특성 상세 조회
  public TraitVO findTraitById(Long traitNo) {
    TraitEntity entity = traitRepository.findById(traitNo)
        .orElseThrow(() -> new EntityNotFoundException(
            "특성을 찾을 수 없습니다. traitNo: " + traitNo));

    if ("Y".equals(entity.getDelYn())) {
      throw new EntityNotFoundException("삭제된 특성입니다. traitNo: " + traitNo);
    }

    return new TraitVO(entity);
  }

  // 특성 생성
  @Transactional
  public TraitVO createTrait(TraitVO traitVO) {
    TraitEntity entity = traitVO.toEntity();
    entity.setCrtNo(1L); // TODO: 인증 구현 후 현재 사용자 번호
    TraitEntity saved = traitRepository.save(entity);
    return new TraitVO(saved);
  }

  // 특성 수정
  @Transactional
  public TraitVO updateTrait(Long traitNo, TraitVO traitVO) {
    TraitEntity entity = traitRepository.findById(traitNo)
        .orElseThrow(() -> new EntityNotFoundException(
            "특성을 찾을 수 없습니다. traitNo: " + traitNo));

    if ("Y".equals(entity.getDelYn())) {
      throw new EntityNotFoundException("삭제된 특성입니다. traitNo: " + traitNo);
    }

    Long updtNo = 1L; // TODO: 인증 구현 후 현재 사용자 번호
    entity.updateTrait(
        traitVO.getTraitNm(),
        traitVO.getTraitExpln(),
        traitVO.getTraitLcls(),
        traitVO.getTraitMcls(),
        traitVO.getAplyTrgt(),
        traitVO.getCnflTrait() != null ? 
            traitRepository.findById(traitVO.getCnflTrait().getTraitNo())
                .orElse(null) : null
    );
    entity.setUpdtNo(updtNo);

    TraitEntity saved = traitRepository.save(entity);
    return new TraitVO(saved);
  }

  // 특성 삭제 (소프트 삭제)
  @Transactional
  public void deleteTrait(Long traitNo, Long deleterNo) {
    TraitEntity entity = traitRepository.findById(traitNo)
        .orElseThrow(() -> new EntityNotFoundException(
            "특성을 찾을 수 없습니다. traitNo: " + traitNo));

    if ("Y".equals(entity.getDelYn())) {
      throw new EntityNotFoundException("이미 삭제된 특성입니다. traitNo: " + traitNo);
    }

    entity.delete(deleterNo);
    traitRepository.save(entity);
  }

  // 검색 조건 빌더
  private Specification<TraitEntity> buildSpecification(TraitVO searchVO) {
    Specification<TraitEntity> spec = Specification.where(
        (root, query, cb) -> cb.equal(root.get("delYn"), "N"));

    // 특성명 검색
    if (searchVO.getTraitNm() != null && !searchVO.getTraitNm().isEmpty()) {
      spec = spec.and((root, query, cb) -> 
          cb.like(cb.lower(root.get("traitNm")),
              "%" + searchVO.getTraitNm().toLowerCase() + "%"));
    }

    // 대분류 필터
    if (searchVO.getTraitLcls() != null && !searchVO.getTraitLcls().isEmpty()) {
      spec = spec.and((root, query, cb) -> 
          cb.equal(root.get("traitLcls"), searchVO.getTraitLcls()));
    }

    // 적용 대상 필터
    if (searchVO.getAplyTrgt() != null && !searchVO.getAplyTrgt().isEmpty()) {
      spec = spec.and((root, query, cb) -> 
          cb.equal(root.get("aplyTrgt"), searchVO.getAplyTrgt()));
    }

    return spec;
  }
}
```

### 주요 메서드 설명

#### `findTraits()` - 목록 조회
- **기능**: 특성 목록을 페이징하여 조회
- **검색 조건**: 특성명, 대분류, 적용 대상
- **반환**: `ListType<TraitVO>` (페이징 정보 포함)

#### `createTrait()` - 특성 생성
- **기능**: 새로운 전역 특성 생성
- **주의**: 상충 특성(`cnflTrait`)은 Entity 객체로 변환해야 함

#### `updateTrait()` - 특성 수정
- **기능**: 기존 특성 정보 수정
- **특징**: `entity.updateTrait()` 메서드를 사용하여 비즈니스 로직을 Entity에 위임

#### `deleteTrait()` - 특성 삭제
- **기능**: 소프트 삭제 (실제로는 `delYn = 'Y'`로 변경)
- **이유**: 이미 사용 중인 특성은 완전 삭제하면 문제가 발생할 수 있음

---

## TraitController - 특성 API

특성 관련 REST API 엔드포인트를 제공하는 컨트롤러입니다.

```java
@RestController
@RequestMapping("/traits")
@RequiredArgsConstructor
public class TraitController {

  private final TraitService traitService;

  // 특성 목록 조회
  @GetMapping
  public ResponseEntity<ApiResponse<ListType<TraitVO>>> getTraits(
      @RequestParam(defaultValue = "1") int page,
      @Valid TraitVO searchVO) {
    ListType<TraitVO> listType = traitService.findTraits(searchVO, page);
    return ResponseEntity.ok(ApiResponse.success(listType));
  }

  // 특성 상세 조회
  @GetMapping("/{traitNo}")
  public ResponseEntity<ApiResponse<TraitVO>> getTrait(
      @PathVariable Long traitNo) {
    TraitVO traitVO = traitService.findTraitById(traitNo);
    return ResponseEntity.ok(ApiResponse.success(traitVO));
  }

  // 특성 생성
  @PostMapping
  public ResponseEntity<ApiResponse<TraitVO>> createTrait(
      @Valid @RequestBody TraitVO traitVO) {
    TraitVO created = traitService.createTrait(traitVO);
    return ResponseEntity.ok(ApiResponse.success(ResponseCode.CREATED, created));
  }

  // 특성 수정
  @PatchMapping("/{traitNo}")
  public ResponseEntity<ApiResponse<TraitVO>> updateTrait(
      @PathVariable Long traitNo,
      @Valid @RequestBody TraitVO traitVO) {
    TraitVO updated = traitService.updateTrait(traitNo, traitVO);
    return ResponseEntity.ok(ApiResponse.success(updated));
  }

  // 특성 삭제
  @DeleteMapping("/{traitNo}")
  public ResponseEntity<ApiResponse<Void>> deleteTrait(
      @PathVariable Long traitNo) {
    Long deleterNo = 1L; // TODO: 인증 구현 후 현재 사용자 번호
    traitService.deleteTrait(traitNo, deleterNo);
    return ResponseEntity.ok(ApiResponse.success(null));
  }
}
```

### API 엔드포인트

| 메서드 | 경로 | 설명 |
|--------|------|------|
| GET | `/traits` | 특성 목록 조회 (페이징, 검색) |
| GET | `/traits/{traitNo}` | 특성 상세 조회 |
| POST | `/traits` | 특성 생성 |
| PATCH | `/traits/{traitNo}` | 특성 수정 |
| DELETE | `/traits/{traitNo}` | 특성 삭제 |

### 사용 예시

#### 특성 목록 조회
```http
GET /traits?page=1&traitNm=불&traitLcls=저항
```

**응답**:
```json
{
  "data": {
    "list": [
      {
        "traitNo": 1,
        "traitNm": "불 저항",
        "traitExpln": "화염 공격에 대한 저항력을 가집니다",
        "traitLcls": "저항",
        "aplyTrgt": "CHAR",
        ...
      }
    ],
    "totalCnt": 1,
    "page": 1,
    "pageSize": 10,
    ...
  },
  "error": false,
  "code": "OK"
}
```

#### 특성 생성
```http
POST /traits
Content-Type: application/json

{
  "traitNm": "불 저항",
  "traitExpln": "화염 공격에 대한 저항력을 가집니다",
  "traitLcls": "저항",
  "traitMcls": "원소 저항",
  "aplyTrgt": "CHAR"
}
```

**응답**:
```json
{
  "data": {
    "traitNo": 1,
    "traitNm": "불 저항",
    ...
  },
  "error": false,
  "code": "CREATED"
}
```

---

## AbilityEntity - 전역 어빌리티 엔티티

어빌리티(Ability)는 캐릭터가 사용할 수 있는 능력이나 스킬입니다.

```java
@Entity
@Getter
@Table(name = "abilities", indexes = {
    @Index(name = "idx_abilities_ability_nm", columnList = "ability_nm")
})
@DynamicInsert
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class AbilityEntity extends CommonEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  @Column(name = "ability_no")
  private Long abilityNo;

  @Column(name = "ability_nm", nullable = false)
  private String abilityNm;  // 어빌리티명

  @Column(name = "ability_type")
  private String abilityType;  // 어빌리티 타입

  @Column(name = "ability_lcls")
  private String abilityLcls;  // 어빌리티 대분류

  @Column(name = "ability_expln", columnDefinition = "TEXT")
  private String abilityExpln;  // 어빌리티 설명

  @Column(name = "trgt_type")
  private String trgtType;  // 대상 타입

  @Column(name = "dmg_type")
  private String dmgType;  // 데미지 타입

  @Column(name = "stat_eff_type")
  private String statEffType;  // 상태 효과 타입

  @Column(name = "use_cost")
  private Integer useCost;  // 사용 비용

  @Column(name = "cool_time")
  private Integer coolTime;  // 쿨타임

  @Column(name = "cast_time")
  private Integer castTime;  // 시전 시간

  @Column(name = "use_cnd", columnDefinition = "TEXT")
  private String useCnd;  // 사용 조건
}
```

### TraitEntity와의 차이점

| 구분 | Trait (특성) | Ability (어빌리티) |
|------|--------------|-------------------|
| **성격** | 지속적인 속성 | 사용하는 능력/스킬 |
| **예시** | "불 저항", "마법 사용" | "파이어볼", "힐링" |
| **특징** | 항상 적용됨 | 사용할 때만 발동 |
| **관계** | 상충 특성 관계 있음 | 상충 관계 없음 |

### 필드 설명

#### `abilityNm` - 어빌리티명
- **예시**: "파이어볼", "힐링", "투명화"

#### `abilityType` - 어빌리티 타입
- **예시**: "공격", "회복", "버프", "디버프"

#### `useCost` - 사용 비용
- **의미**: 이 어빌리티를 사용하는 데 필요한 비용 (마나, 스태미나 등)
- **예시**: 10 (마나 10 소모)

#### `coolTime` - 쿨타임
- **의미**: 어빌리티를 사용한 후 다시 사용할 수 있을 때까지의 시간
- **예시**: 30 (30초 쿨타임)

#### `castTime` - 시전 시간
- **의미**: 어빌리티를 발동하는 데 걸리는 시간
- **예시**: 2 (2초 시전 시간)

#### `useCnd` - 사용 조건
- **의미**: 이 어빌리티를 사용하기 위한 조건
- **예시**: "마나 10 이상", "전투 상태"

---

## 전체 흐름 정리

### 특성 생성 흐름

```
1. 클라이언트 요청
   POST /traits
   {
     "traitNm": "불 저항",
     "traitExpln": "화염 공격에 대한 저항력을 가집니다",
     "traitLcls": "저항",
     "aplyTrgt": "CHAR"
   }

2. TraitController
   - @PostMapping으로 요청 받음
   - @Valid로 유효성 검증
   - traitService.createTrait(traitVO) 호출

3. TraitService
   - VO → Entity 변환
   - 생성자 번호 설정
   - traitRepository.save(entity) 호출

4. TraitRepository
   - JPA가 INSERT 쿼리 생성 및 실행
   - INSERT INTO traits (trait_nm, trait_expln, ...) VALUES (...)

5. 데이터베이스
   - 레코드 저장
   - 생성된 trait_no 반환

6. TraitRepository → TraitService
   - 저장된 TraitEntity 반환

7. TraitService
   - Entity → VO 변환

8. TraitService → TraitController
   - TraitVO 반환

9. TraitController
   - ApiResponse로 래핑
   - JSON으로 변환하여 응답

10. 클라이언트 응답
    {
      "data": {
        "traitNo": 1,
        "traitNm": "불 저항",
        ...
      },
      "error": false,
      "code": "CREATED"
    }
```

### 특성 목록 조회 흐름

```
1. 클라이언트 요청
   GET /traits?page=1&traitNm=불&traitLcls=저항

2. TraitController
   - @GetMapping으로 요청 받음
   - 쿼리 파라미터를 TraitVO에 자동 바인딩
   - traitService.findTraits(searchVO, 1) 호출

3. TraitService
   - Pageable 생성
   - Specification으로 검색 조건 구성
   - traitRepository.findAll(spec, pageable) 호출

4. TraitRepository
   - JPA가 동적 쿼리 생성 및 실행
   - SELECT * FROM traits 
     WHERE del_yn = 'N' 
     AND LOWER(trait_nm) LIKE '%불%' 
     AND trait_lcls = '저항'
     LIMIT 10 OFFSET 0

5. 데이터베이스
   - 쿼리 실행 결과 반환

6. TraitRepository → TraitService
   - Page<TraitEntity> 반환

7. TraitService
   - Entity를 VO로 변환
   - ListType으로 래핑

8. TraitService → TraitController
   - ListType<TraitVO> 반환

9. TraitController
   - ApiResponse로 래핑
   - JSON으로 변환하여 응답

10. 클라이언트 응답
    {
      "data": {
        "list": [...],
        "totalCnt": 5,
        "page": 1,
        ...
      },
      "error": false,
      "code": "OK"
    }
```

---

## 다음 단계

이제 전역 풀 엔티티를 이해했으니, 프로젝트의 전체 구조와 각 계층의 역할을 정리해보겠습니다.

[다음: 07. 프로젝트 구조 정리](./07_프로젝트_구조_정리.md)
