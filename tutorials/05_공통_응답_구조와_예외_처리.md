# 05. 공통 응답 구조와 예외 처리

## 목차
1. [공통 응답 구조의 필요성](#공통-응답-구조의-필요성)
2. [ApiResponse - 응답 래퍼 클래스](#apiresponse---응답-래퍼-클래스)
3. [ResponseCode - 응답 코드 Enum](#responsecode---응답-코드-enum)
4. [ListType - 목록 응답 구조](#listtype---목록-응답-구조)
5. [GlobalExceptionHandler - 전역 예외 처리](#globalexceptionhandler---전역-예외-처리)
6. [BusinessException - 커스텀 예외](#businessexception---커스텀-예외)
7. [전체 흐름 정리](#전체-흐름-정리)

---

## 공통 응답 구조의 필요성

### 문제점: 일관성 없는 응답

만약 공통 응답 구조가 없다면:

**성공 응답**:
```json
{
  "userNo": 1,
  "userEml": "test@example.com"
}
```

**에러 응답**:
```json
{
  "error": "사용자를 찾을 수 없습니다"
}
```

**문제점**:
- 클라이언트가 성공/실패를 구분하기 어려움
- 에러 코드가 일관되지 않음
- 페이징 정보를 포함하기 어려움

### 해결책: 공통 응답 구조

모든 API 응답을 일관된 형식으로 래핑:

**성공 응답**:
```json
{
  "data": {
    "userNo": 1,
    "userEml": "test@example.com"
  },
  "error": false,
  "code": "OK",
  "message": "요청 성공"
}
```

**에러 응답**:
```json
{
  "data": null,
  "error": true,
  "code": "NOT_FOUND",
  "message": "사용자를 찾을 수 없습니다"
}
```

**장점**:
- 클라이언트가 항상 같은 구조로 응답을 처리할 수 있음
- 에러 코드로 정확한 오류 유형 파악 가능
- 페이징 정보를 쉽게 추가 가능

---

## ApiResponse - 응답 래퍼 클래스

모든 API 응답을 래핑하는 제네릭 클래스입니다.

```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
  
  private T data;              // 응답 데이터 (제네릭 타입)
  private boolean error;       // 에러 여부 (true: 에러, false: 성공)
  private String code;         // 응답 코드 (ResponseCode Enum의 value)
  private String message;      // 응답 메시지

  // 성공 응답 생성 (기본 코드: OK)
  public static <T> ApiResponse<T> success(T data) {
    return new ApiResponse<>(
      data,
      false,
      ResponseCode.OK.getValue(),
      ResponseCode.OK.getDescription()
    );
  }

  // 성공 응답 생성 (커스텀 코드)
  public static <T> ApiResponse<T> success(ResponseCode code, T data) {
    return new ApiResponse<>(
      data,
      false,
      code.getValue(),
      code.getDescription()
    );
  }

  // 에러 응답 생성
  public static <T> ApiResponse<T> error(ResponseCode code, String message) {
    return new ApiResponse<>(
      null,
      true,
      code.getValue(),
      message
    );
  }
}
```

### 어노테이션 설명

#### `@AllArgsConstructor`
- **역할**: 모든 필드를 파라미터로 받는 생성자를 자동 생성
- **효과**: `new ApiResponse<>(data, false, "OK", "성공")`처럼 사용 가능

### 제네릭 타입 `<T>`

**왜 제네릭을 사용하나요?**
- 다양한 타입의 데이터를 담을 수 있음
- 타입 안정성 보장

**사용 예시**:
```java
// 사용자 정보 응답
ApiResponse<UserVO> userResponse = ApiResponse.success(userVO);

// 사용자 목록 응답
ApiResponse<ListType<UserVO>> listResponse = ApiResponse.success(listType);

// 빈 응답 (삭제 성공 등)
ApiResponse<Void> voidResponse = ApiResponse.success(null);
```

### 정적 팩토리 메서드

#### `success(T data)` - 기본 성공 응답
```java
ApiResponse<UserVO> response = ApiResponse.success(userVO);
```

**결과**:
```json
{
  "data": { "userNo": 1, ... },
  "error": false,
  "code": "OK",
  "message": "요청 성공"
}
```

#### `success(ResponseCode code, T data)` - 커스텀 코드 성공 응답
```java
ApiResponse<UserVO> response = ApiResponse.success(ResponseCode.CREATED, userVO);
```

**결과**:
```json
{
  "data": { "userNo": 1, ... },
  "error": false,
  "code": "CREATED",
  "message": "리소스 생성 성공"
}
```

**사용 시점**: 리소스를 생성했을 때 (POST 요청)

#### `error(ResponseCode code, String message)` - 에러 응답
```java
ApiResponse<Void> response = ApiResponse.error(
    ResponseCode.NOT_FOUND, 
    "사용자를 찾을 수 없습니다"
);
```

**결과**:
```json
{
  "data": null,
  "error": true,
  "code": "NOT_FOUND",
  "message": "사용자를 찾을 수 없습니다"
}
```

---

## ResponseCode - 응답 코드 Enum

모든 API 응답에서 사용되는 응답 코드를 정의한 Enum입니다.

```java
@Getter
public enum ResponseCode {

  // 성공 응답 (2xx)
  OK("OK", "요청 성공"),
  CREATED("CREATED", "리소스 생성 성공"),
  NO_CONTENT("NO_CONTENT", "성공했으나 반환할 내용 없음"),

  // 클라이언트 에러 (4xx)
  BAD_REQUEST("BAD_REQUEST", "잘못된 요청"),
  UNAUTHORIZED("UNAUTHORIZED", "인증 필요 (로그인이 필요함)"),
  FORBIDDEN("FORBIDDEN", "권한 없음 (접근 권한이 없음)"),
  NOT_FOUND("NOT_FOUND", "리소스를 찾을 수 없음"),
  VALIDATION_ERROR("VALIDATION_ERROR", "입력값 검증 실패"),

  // 인증 관련 에러
  INVALID_CREDENTIALS("INVALID_CREDENTIALS", 
      "잘못된 인증 정보 (이메일 또는 비밀번호가 올바르지 않음)"),
  EMAIL_ALREADY_EXISTS("EMAIL_ALREADY_EXISTS", "이메일이 이미 존재함"),
  INVALID_TOKEN("INVALID_TOKEN", "잘못된 토큰"),
  ACCOUNT_LOCKED("ACCOUNT_LOCKED", "계정이 잠금됨"),

  // 서버 에러 (5xx)
  INTERNAL_SERVER_ERROR("INTERNAL_SERVER_ERROR", "내부 서버 오류");

  private final String value;        // 응답 코드 문자열
  private final String description;  // 응답 코드 설명

  ResponseCode(String value, String description) {
    this.value = value;
    this.description = description;
  }
}
```

### Enum이란?

**Enum (열거형)**: 미리 정의된 상수들의 집합

**예시**:
```java
// ❌ 이렇게 하면 안 됩니다
String code = "OK";  // 오타 가능, 유효하지 않은 값 가능

// ✅ Enum 사용
ResponseCode code = ResponseCode.OK;  // 타입 안정성, 유효한 값만 사용 가능
```

**장점**:
- **타입 안정성**: 컴파일 시점에 오류 발견
- **자동완성**: IDE에서 사용 가능한 값들을 제안
- **문서화**: 각 코드의 의미가 명확함

### 사용 예시

```java
// 성공 응답
return ApiResponse.success(ResponseCode.CREATED, userVO);

// 에러 응답
throw new BusinessException(ResponseCode.NOT_FOUND, "사용자를 찾을 수 없습니다");
```

---

## ListType - 목록 응답 구조

목록 조회 API의 응답을 위한 구조화된 클래스입니다.

```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
public class ListType<T> {

  private List<T> list;        // 실제 데이터 목록 (필수)
  private Long totalCnt;       // 전체 아이템 개수 (필수)
  private Integer pageSize;    // 페이지 크기 (페이징 있는 경우)
  private Integer page;        // 현재 페이지 번호 (페이징 있는 경우)
  private Integer totalPage;   // 전체 페이지 수 (페이징 있는 경우)
  private Boolean isFirst;     // 첫 페이지 여부 (페이징 있는 경우)
  private Boolean isLast;      // 마지막 페이지 여부 (페이징 있는 경우)
}
```

### 필수 필드 vs 선택 필드

#### 필수 필드 (항상 채움)
- **`list`**: 실제 데이터 목록
- **`totalCnt`**: 전체 아이템 개수

#### 선택 필드 (페이징이 있는 경우만 채움)
- **`pageSize`**: 페이지 크기
- **`page`**: 현재 페이지 번호
- **`totalPage`**: 전체 페이지 수
- **`isFirst`**: 첫 페이지 여부
- **`isLast`**: 마지막 페이지 여부

### 사용 예시

#### 페이징이 있는 경우
```java
ListType<UserVO> listType = new ListType<>(
    voList,           // List<UserVO>
    100L,             // totalCnt: 전체 100개
    10,               // pageSize: 페이지당 10개
    1,                // page: 현재 1페이지
    10,               // totalPage: 전체 10페이지
    true,             // isFirst: 첫 페이지
    false             // isLast: 마지막 페이지 아님
);
```

**응답**:
```json
{
  "data": {
    "list": [...],
    "totalCnt": 100,
    "pageSize": 10,
    "page": 1,
    "totalPage": 10,
    "isFirst": true,
    "isLast": false
  },
  "error": false,
  "code": "OK"
}
```

#### 페이징이 없는 경우
```java
ListType<UserVO> listType = new ListType<>(
    voList,           // List<UserVO>
    (long) voList.size(),  // totalCnt: 리스트 크기
    null,             // pageSize: null
    null,             // page: null
    null,             // totalPage: null
    null,             // isFirst: null
    null              // isLast: null
);
```

**응답**:
```json
{
  "data": {
    "list": [...],
    "totalCnt": 5,
    "pageSize": null,
    "page": null,
    "totalPage": null,
    "isFirst": null,
    "isLast": null
  },
  "error": false,
  "code": "OK"
}
```

### 왜 totalCnt는 항상 채우나요?

**이유**: 클라이언트가 전체 개수를 알면 유용한 정보를 제공할 수 있습니다
- "전체 100개 중 1-10번째 표시"
- "더 보기" 버튼 표시 여부 결정

---

## GlobalExceptionHandler - 전역 예외 처리

모든 컨트롤러에서 발생하는 예외를 일관된 형식으로 처리하는 핸들러입니다.

```java
@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

  // EntityNotFoundException 처리
  @ExceptionHandler(EntityNotFoundException.class)
  public ResponseEntity<ApiResponse<Void>> handleEntityNotFound(
      EntityNotFoundException e) {
    log.warn("Entity not found: {}", e.getMessage());
    return ResponseEntity.ok(ApiResponse.error(
        ResponseCode.NOT_FOUND, 
        e.getMessage()
    ));
  }

  // 입력값 검증 실패 처리
  @ExceptionHandler(MethodArgumentNotValidException.class)
  public ResponseEntity<ApiResponse<Void>> handleValidationException(
      MethodArgumentNotValidException e) {
    log.warn("Validation error: {}", e.getMessage());
    
    String errorMessage = e.getBindingResult().getFieldErrors().stream()
        .findFirst()
        .map(error -> error.getField() + ": " + error.getDefaultMessage())
        .orElse("입력값 검증 실패");
    
    return ResponseEntity.ok(ApiResponse.error(
        ResponseCode.VALIDATION_ERROR, 
        errorMessage
    ));
  }

  // 커스텀 비즈니스 예외 처리
  @ExceptionHandler(BusinessException.class)
  public ResponseEntity<ApiResponse<Void>> handleBusinessException(
      BusinessException e) {
    log.warn("Business exception: {} - {}", e.getResponseCode(), e.getMessage());
    return ResponseEntity.ok(ApiResponse.error(
        e.getResponseCode(), 
        e.getMessage()
    ));
  }

  // 기타 예외 처리 (모든 예외의 최종 처리)
  @ExceptionHandler(Exception.class)
  public ResponseEntity<ApiResponse<Void>> handleException(Exception e) {
    log.error("Unexpected error occurred", e);
    return ResponseEntity.ok(ApiResponse.error(
        ResponseCode.INTERNAL_SERVER_ERROR,
        "서버 내부 오류가 발생했습니다. 관리자에게 문의하세요."
    ));
  }
}
```

### 어노테이션 설명

#### `@RestControllerAdvice`
- **역할**: 모든 `@RestController`에서 발생하는 예외를 처리합니다
- **효과**: 각 컨트롤러에서 예외 처리 코드를 작성할 필요가 없습니다
- **조합**: `@ControllerAdvice` + `@ResponseBody`

#### `@ExceptionHandler`
- **역할**: 특정 예외 타입을 처리하는 메서드임을 나타냅니다
- **파라미터**: 처리할 예외 타입 (예: `EntityNotFoundException.class`)
- **효과**: 해당 예외가 발생하면 이 메서드가 자동으로 호출됩니다

### 예외 처리 우선순위

예외 처리 메서드는 **구체적인 것부터 일반적인 것 순서**로 작성합니다:

```java
// 1. 가장 구체적인 예외 (우선 처리)
@ExceptionHandler(BusinessException.class)
public ResponseEntity<...> handleBusinessException(...) { ... }

// 2. 일반적인 예외
@ExceptionHandler(IllegalArgumentException.class)
public ResponseEntity<...> handleIllegalArgument(...) { ... }

// 3. 모든 예외의 최종 처리 (가장 마지막)
@ExceptionHandler(Exception.class)
public ResponseEntity<...> handleException(...) { ... }
```

**이유**: `Exception`은 모든 예외의 부모 클래스이므로, 가장 마지막에 두어 다른 핸들러가 처리하지 못한 예외만 처리합니다.

### 주요 예외 처리 설명

#### EntityNotFoundException
```java
@ExceptionHandler(EntityNotFoundException.class)
public ResponseEntity<ApiResponse<Void>> handleEntityNotFound(
    EntityNotFoundException e) {
  return ResponseEntity.ok(ApiResponse.error(
      ResponseCode.NOT_FOUND, 
      e.getMessage()
  ));
}
```

**발생 시점**: 
- `userRepository.findById(userNo).orElseThrow(() -> new EntityNotFoundException(...))`
- 데이터베이스에서 엔티티를 찾을 수 없을 때

**응답**:
```json
{
  "data": null,
  "error": true,
  "code": "NOT_FOUND",
  "message": "사용자를 찾을 수 없습니다. userNo: 999"
}
```

#### MethodArgumentNotValidException
```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<ApiResponse<Void>> handleValidationException(
    MethodArgumentNotValidException e) {
  String errorMessage = e.getBindingResult().getFieldErrors().stream()
      .findFirst()
      .map(error -> error.getField() + ": " + error.getDefaultMessage())
      .orElse("입력값 검증 실패");
  
  return ResponseEntity.ok(ApiResponse.error(
      ResponseCode.VALIDATION_ERROR, 
      errorMessage
  ));
}
```

**발생 시점**: 
- `@Valid` 어노테이션이 붙은 파라미터의 검증이 실패했을 때
- 예: `@Email`, `@NotNull` 등의 검증 어노테이션 위반

**응답**:
```json
{
  "data": null,
  "error": true,
  "code": "VALIDATION_ERROR",
  "message": "userEml: 이메일 형식이 올바르지 않습니다"
}
```

#### BusinessException
```java
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ApiResponse<Void>> handleBusinessException(
    BusinessException e) {
  return ResponseEntity.ok(ApiResponse.error(
      e.getResponseCode(), 
      e.getMessage()
  ));
}
```

**발생 시점**: 
- 비즈니스 로직에서 발생하는 커스텀 예외
- 예: 이메일 중복, 계정 잠금 등

**응답**:
```json
{
  "data": null,
  "error": true,
  "code": "EMAIL_ALREADY_EXISTS",
  "message": "이미 사용 중인 이메일입니다."
}
```

---

## BusinessException - 커스텀 예외

비즈니스 로직에서 발생하는 커스텀 예외 클래스입니다.

```java
public class BusinessException extends RuntimeException {

  private final ResponseCode responseCode;

  public BusinessException(ResponseCode responseCode, String message) {
    super(message);
    this.responseCode = responseCode;
  }

  public ResponseCode getResponseCode() {
    return responseCode;
  }
}
```

### 왜 커스텀 예외를 만들었나요?

**일반 예외의 문제점**:
```java
// ❌ 이렇게 하면 응답 코드를 지정하기 어려움
throw new RuntimeException("이미 사용 중인 이메일입니다.");
```

**커스텀 예외의 장점**:
```java
// ✅ 응답 코드를 명확히 지정 가능
throw new BusinessException(
    ResponseCode.EMAIL_ALREADY_EXISTS, 
    "이미 사용 중인 이메일입니다."
);
```

### 사용 예시

```java
// 이메일 중복 검증
if (userRepository.findByUserEml(userVO.getUserEml()).isPresent()) {
  throw new BusinessException(
      ResponseCode.EMAIL_ALREADY_EXISTS, 
      "이미 사용 중인 이메일입니다."
  );
}

// 계정 잠금 확인
if ("Y".equals(user.getAcntLckYn())) {
  throw new BusinessException(
      ResponseCode.ACCOUNT_LOCKED, 
      "계정이 잠금되었습니다."
  );
}
```

---

## 전체 흐름 정리

### 성공 응답 흐름

```
1. Controller
   UserVO userVO = userService.findUserById(userNo);
   return ResponseEntity.ok(ApiResponse.success(userVO));

2. ApiResponse.success()
   - data: userVO
   - error: false
   - code: "OK"
   - message: "요청 성공"

3. JSON 변환
   {
     "data": { "userNo": 1, ... },
     "error": false,
     "code": "OK",
     "message": "요청 성공"
   }

4. 클라이언트 응답
```

### 에러 응답 흐름

```
1. Service
   throw new BusinessException(
       ResponseCode.NOT_FOUND, 
       "사용자를 찾을 수 없습니다"
   );

2. GlobalExceptionHandler
   @ExceptionHandler(BusinessException.class)
   - 예외를 잡아서 ApiResponse.error()로 변환

3. ApiResponse.error()
   - data: null
   - error: true
   - code: "NOT_FOUND"
   - message: "사용자를 찾을 수 없습니다"

4. JSON 변환
   {
     "data": null,
     "error": true,
     "code": "NOT_FOUND",
     "message": "사용자를 찾을 수 없습니다"
   }

5. 클라이언트 응답
```

### 입력값 검증 실패 흐름

```
1. Controller
   @PostMapping
   public ResponseEntity<...> createUser(@Valid @RequestBody UserVO userVO) {
     ...
   }

2. @Valid 검증 실패
   - userVO.getUserEml()이 null이거나 이메일 형식이 아님
   - MethodArgumentNotValidException 발생

3. GlobalExceptionHandler
   @ExceptionHandler(MethodArgumentNotValidException.class)
   - 첫 번째 검증 오류 메시지 추출
   - ApiResponse.error()로 변환

4. JSON 변환
   {
     "data": null,
     "error": true,
     "code": "VALIDATION_ERROR",
     "message": "userEml: 이메일 형식이 올바르지 않습니다"
   }

5. 클라이언트 응답
```

---

## 다음 단계

이제 공통 응답 구조와 예외 처리를 이해했으니, **전역 풀 엔티티 (Trait, Ability)**가 어떻게 구현되었는지 살펴보겠습니다.

[다음: 06. 전역 풀 엔티티 구현하기](./06_전역_풀_엔티티_구현하기.md)
