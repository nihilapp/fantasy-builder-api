# 04. 인증 시스템 구현하기

## 목차
1. [인증 시스템 개요](#인증-시스템-개요)
2. [JWT 토큰 이해하기](#jwt-토큰-이해하기)
3. [JwtHelper - 토큰 생성 및 검증](#jwthelper---토큰-생성-및-검증)
4. [비밀번호 해싱 - PasswordHelper](#비밀번호-해싱---passwordhelper)
5. [AuthService - 인증 비즈니스 로직](#authservice---인증-비즈니스-로직)
6. [JwtAuthenticationFilter - 인증 필터](#jwtauthenticationfilter---인증-필터)
7. [SecurityConfig - 보안 설정](#securityconfig---보안-설정)
8. [전체 인증 흐름](#전체-인증-흐름)

---

## 인증 시스템 개요

인증 시스템은 사용자가 누구인지 확인하고, 인증된 사용자만 리소스에 접근할 수 있도록 보장합니다.

### 인증 방식: JWT (JSON Web Token)

이 프로젝트는 **JWT 토큰 기반 인증**을 사용합니다.

**JWT의 장점**:
- **Stateless**: 서버에 세션을 저장하지 않아도 됨 (확장성 좋음)
- **자기 포함적**: 토큰 자체에 사용자 정보가 포함되어 있음
- **분산 시스템에 적합**: 여러 서버에서 동일한 토큰을 검증 가능

### 인증 프로세스

```
1. 로그인
   사용자 → 이메일/비밀번호 입력
   ↓
   서버 → 비밀번호 검증 → JWT 토큰 발급 → 쿠키에 저장

2. 인증된 요청
   사용자 → API 요청 (쿠키에 토큰 포함)
   ↓
   서버 → 토큰 검증 → 사용자 정보 추출 → 요청 처리

3. 토큰 갱신
   사용자 → Refresh Token으로 새 토큰 요청
   ↓
   서버 → Refresh Token 검증 → 새 Access Token 발급
```

---

## JWT 토큰 이해하기

### JWT 구조

JWT는 세 부분으로 구성됩니다:

```
[Header].[Payload].[Signature]
```

#### 1. Header (헤더)
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```
- **역할**: 토큰 타입과 서명 알고리즘 정보
- **예시**: HS256 (HMAC SHA256) 알고리즘 사용

#### 2. Payload (페이로드)
```json
{
  "userNo": 1,
  "userEml": "test@example.com",
  "userRole": "USER",
  "type": "access",
  "iat": 1234567890,
  "exp": 1234571490
}
```
- **역할**: 실제 데이터 (사용자 정보, 만료 시간 등)
- **클레임(Claims)**: Payload에 포함된 정보들
  - `userNo`: 사용자 번호
  - `userEml`: 이메일
  - `userRole`: 역할
  - `type`: 토큰 타입 (access 또는 refresh)
  - `iat`: 발급 시간 (issued at)
  - `exp`: 만료 시간 (expiration)

#### 3. Signature (서명)
```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```
- **역할**: 토큰이 변조되지 않았는지 검증
- **동작**: Header와 Payload를 비밀키로 서명하여 생성

### Access Token vs Refresh Token

#### Access Token
- **유효 기간**: 1시간 (짧음)
- **용도**: API 요청 시 인증에 사용
- **위치**: 쿠키에 저장
- **특징**: 만료되면 새로 발급받아야 함

#### Refresh Token
- **유효 기간**: 1주일 (김)
- **용도**: Access Token을 갱신할 때 사용
- **위치**: 쿠키에 저장 (또는 데이터베이스)
- **특징**: 
  - Access Token이 만료되면 Refresh Token으로 새 Access Token 발급
  - Refresh Token도 만료되면 다시 로그인해야 함

**왜 두 개의 토큰을 사용하나요?**
- **보안**: Access Token이 탈취되어도 짧은 유효 기간으로 피해 최소화
- **사용자 경험**: Refresh Token으로 자동 갱신하여 로그인 유지

---

## JwtHelper - 토큰 생성 및 검증

JWT 토큰을 생성하고 검증하는 유틸리티 클래스입니다.

```java
@Component
public class JwtHelper {

  @Value("${jwt.secret}")
  private String secret;

  @Value("${jwt.access-token-expiration}")
  private Long accessTokenExpiration;

  @Value("${jwt.refresh-token-expiration}")
  private Long refreshTokenExpiration;

  // Access Token 생성
  public String generateAccessToken(Long userNo, String userEml, String userRole) {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userNo", userNo);
    claims.put("userEml", userEml);
    claims.put("userRole", userRole);
    claims.put("type", "access");

    return createToken(claims, userNo.toString(), accessTokenExpiration);
  }

  // Refresh Token 생성
  public String generateRefreshToken(Long userNo) {
    Map<String, Object> claims = new HashMap<>();
    claims.put("userNo", userNo);
    claims.put("type", "refresh");

    return createToken(claims, userNo.toString(), refreshTokenExpiration);
  }

  // 토큰 생성 (내부 메서드)
  private String createToken(Map<String, Object> claims, String subject, Long expiration) {
    Date now = new Date();
    Date expiryDate = new Date(now.getTime() + expiration);

    return Jwts.builder()
        .claims(claims)           // 페이로드에 클레임 추가
        .subject(subject)         // 주제 (사용자 번호)
        .issuedAt(now)            // 발급 시간
        .expiration(expiryDate)   // 만료 시간
        .signWith(getSigningKey()) // 서명
        .compact();               // 최종 토큰 문자열 생성
  }
}
```

### 어노테이션 설명

#### `@Component`
- **역할**: Spring이 이 클래스를 빈으로 등록합니다
- **효과**: 다른 클래스에서 `@Autowired` 또는 생성자 주입으로 사용 가능

#### `@Value("${jwt.secret}")`
- **역할**: `application.yml`에서 설정 값을 주입합니다
- **예시**: `jwt.secret: your-secret-key` → `secret` 변수에 주입
- **왜 사용하나요?**: 설정 파일에서 관리하여 코드 수정 없이 변경 가능

### 주요 메서드 설명

#### `generateAccessToken()` - Access Token 생성
```java
public String generateAccessToken(Long userNo, String userEml, String userRole) {
  Map<String, Object> claims = new HashMap<>();
  claims.put("userNo", userNo);
  claims.put("userEml", userEml);
  claims.put("userRole", userRole);
  claims.put("type", "access");

  return createToken(claims, userNo.toString(), accessTokenExpiration);
}
```

**동작 과정**:
1. 클레임 맵 생성 (사용자 정보 포함)
2. 토큰 타입을 "access"로 설정
3. `createToken()` 호출하여 토큰 생성
4. 유효 기간: 1시간 (`accessTokenExpiration`)

#### `generateRefreshToken()` - Refresh Token 생성
```java
public String generateRefreshToken(Long userNo) {
  Map<String, Object> claims = new HashMap<>();
  claims.put("userNo", userNo);
  claims.put("type", "refresh");

  return createToken(claims, userNo.toString(), refreshTokenExpiration);
}
```

**차이점**:
- Access Token보다 클레임이 적음 (사용자 번호만)
- 유효 기간: 1주일 (`refreshTokenExpiration`)

#### `validateToken()` - 토큰 검증
```java
public Boolean validateToken(String token, String expectedType) {
  try {
    // 1. 만료 확인
    if (isTokenExpired(token)) {
      return false;
    }

    // 2. 토큰 타입 확인
    String tokenType = getTokenTypeFromToken(token);
    if (expectedType != null && !expectedType.equals(tokenType)) {
      return false;
    }

    return true;
  } catch (Exception e) {
    return false;
  }
}
```

**검증 과정**:
1. 토큰이 만료되었는지 확인
2. 토큰 타입이 예상한 것과 일치하는지 확인
3. 서명이 유효한지 확인 (JWT 라이브러리가 자동 처리)

#### `getUserIdFromToken()` - 사용자 번호 추출
```java
public Long getUserIdFromToken(String token) {
  String subject = getClaimFromToken(token, Claims::getSubject);
  return subject != null ? Long.parseLong(subject) : null;
}
```

**동작**: 토큰의 `subject` (사용자 번호)를 추출하여 반환

---

## 비밀번호 해싱 - PasswordHelper

비밀번호를 안전하게 저장하기 위해 해싱하는 유틸리티입니다.

```java
@Component
@RequiredArgsConstructor
public class PasswordHelper {

  private final PasswordEncoder passwordEncoder;

  // 비밀번호 해싱
  public String encode(String rawPassword) {
    if (rawPassword == null || rawPassword.isEmpty()) {
      throw new IllegalArgumentException("비밀번호는 필수입니다.");
    }
    return passwordEncoder.encode(rawPassword);
  }

  // 비밀번호 검증
  public boolean matches(String rawPassword, String encodedPassword) {
    if (rawPassword == null || encodedPassword == null) {
      return false;
    }
    return passwordEncoder.matches(rawPassword, encodedPassword);
  }
}
```

### 왜 비밀번호를 해싱하나요?

**절대 하면 안 되는 것**:
```java
// ❌ 절대 이렇게 하면 안 됩니다!
user.setPassword("Password123!");  // 평문으로 저장
```

**문제점**:
- 데이터베이스가 유출되면 모든 비밀번호가 노출됨
- 사용자가 여러 사이트에서 같은 비밀번호를 사용하는 경우 위험

**올바른 방법**:
```java
// ✅ 해싱하여 저장
String hashedPassword = passwordHelper.encode("Password123!");
user.setEnpswd(hashedPassword);  // 해시값 저장
```

**장점**:
- 해시값은 원래 비밀번호로 복원 불가능 (단방향)
- 데이터베이스가 유출되어도 원래 비밀번호는 알 수 없음

### BCrypt 알고리즘

이 프로젝트는 **BCrypt** 알고리즘을 사용합니다.

**BCrypt의 특징**:
- **솔트(Salt) 자동 생성**: 같은 비밀번호라도 매번 다른 해시값 생성
- **느린 해싱**: 무차별 대입 공격에 강함
- **비용 인자(Cost Factor)**: 해싱 속도를 조절하여 보안 강화

**예시**:
```java
// 같은 비밀번호를 해싱해도 결과가 다름
passwordHelper.encode("Password123!"); 
// → "$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy"

passwordHelper.encode("Password123!"); 
// → "$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.H/HuVYVqJqJqJqJqJqJqJq"
```

**비밀번호 검증**:
```java
// 평문 비밀번호와 해시값을 비교
boolean matches = passwordHelper.matches("Password123!", hashedPassword);
// → true (일치) 또는 false (불일치)
```

---

## AuthService - 인증 비즈니스 로직

인증 관련 비즈니스 로직을 처리하는 서비스입니다.

### 로그인 (signin)

```java
@Transactional
public SigninResult signin(UserVO userVO, String clientIp) {
  // 1. 사용자 조회
  UserEntity user = userRepository.findByUserEml(userVO.getUserEml())
      .orElseThrow(() -> new BusinessException(ResponseCode.INVALID_CREDENTIALS,
          "이메일 또는 비밀번호가 올바르지 않습니다."));

  // 2. 삭제된 사용자 확인
  if ("Y".equals(user.getDelYn())) {
    throw new BusinessException(ResponseCode.INVALID_CREDENTIALS, ...);
  }

  // 3. 계정 잠금 확인
  if ("Y".equals(user.getAcntLckYn())) {
    throw new BusinessException(ResponseCode.ACCOUNT_LOCKED, "계정이 잠금되었습니다.");
  }

  // 4. 비밀번호 검증
  if (!passwordHelper.matches(userVO.getPassword(), user.getEnpswd())) {
    // 로그인 실패 처리
    user.recordLoginFailure();
    if (user.getLgnFailNmtm() >= maxLoginFailures) {
      user.lockAccount();
      userRepository.save(user);
      throw new BusinessException(ResponseCode.ACCOUNT_LOCKED, ...);
    }
    userRepository.save(user);
    throw new BusinessException(ResponseCode.INVALID_CREDENTIALS, ...);
  }

  // 5. 로그인 성공 처리
  user.recordLoginSuccess(clientIp);

  // 6. 토큰 생성
  String accessToken = jwtHelper.generateAccessToken(
      user.getUserNo(), user.getUserEml(), user.getUserRole().toString());
  String refreshToken = jwtHelper.generateRefreshToken(user.getUserNo());

  // 7. Refresh Token 저장
  user.setReshToken(refreshToken);
  userRepository.save(user);

  // 8. 결과 반환
  UserVO response = new UserVO(user);
  TokenPair tokenPair = new TokenPair(accessToken, refreshToken);
  return new SigninResult(response, tokenPair);
}
```

**흐름 설명**:
1. **사용자 조회**: 이메일로 사용자 찾기
2. **삭제 확인**: 삭제된 사용자는 로그인 불가
3. **계정 잠금 확인**: 잠긴 계정은 로그인 불가
4. **비밀번호 검증**: 평문 비밀번호와 해시값 비교
   - 실패 시: 실패 횟수 증가, 5회 이상이면 계정 잠금
5. **로그인 성공**: 실패 횟수 초기화, 마지막 로그인 정보 업데이트
6. **토큰 생성**: Access Token과 Refresh Token 생성
7. **Refresh Token 저장**: 데이터베이스에 저장 (나중에 검증용)
8. **결과 반환**: 사용자 정보와 토큰 쌍 반환

### 토큰 갱신 (refresh)

```java
@Transactional
public TokenPair refresh(String refreshToken) {
  // 1. Refresh Token 검증
  if (!jwtHelper.validateToken(refreshToken, "refresh")) {
    throw new BusinessException(ResponseCode.INVALID_TOKEN, ...);
  }

  // 2. 사용자 번호 추출
  Long userNo = jwtHelper.getUserIdFromToken(refreshToken);

  // 3. 사용자 조회 및 Refresh Token 확인
  UserEntity user = userRepository.findById(userNo)
      .orElseThrow(() -> new BusinessException(ResponseCode.INVALID_TOKEN, ...));

  if (!refreshToken.equals(user.getReshToken())) {
    throw new BusinessException(ResponseCode.INVALID_TOKEN, ...);
  }

  // 4. 새로운 토큰 생성
  String newAccessToken = jwtHelper.generateAccessToken(...);
  String newRefreshToken = jwtHelper.generateRefreshToken(user.getUserNo());

  // 5. Refresh Token 업데이트
  user.setReshToken(newRefreshToken);
  userRepository.save(user);

  return new TokenPair(newAccessToken, newRefreshToken);
}
```

**흐름 설명**:
1. **토큰 검증**: Refresh Token이 유효한지 확인
2. **사용자 확인**: 토큰의 사용자 번호로 사용자 조회
3. **토큰 일치 확인**: 데이터베이스에 저장된 Refresh Token과 일치하는지 확인
   - **왜 필요한가요?**: 토큰이 탈취되어 사용되더라도, 이미 새로운 토큰으로 갱신되었다면 이전 토큰은 무효화됨
4. **새 토큰 생성**: Access Token과 Refresh Token 모두 새로 생성
5. **Refresh Token 업데이트**: 데이터베이스에 새 Refresh Token 저장

---

## JwtAuthenticationFilter - 인증 필터

모든 HTTP 요청이 컨트롤러에 도달하기 전에 JWT 토큰을 검증하는 필터입니다.

```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

  private final JwtHelper jwtHelper;
  private final CookieHelper cookieHelper;

  @Override
  protected void doFilterInternal(
      HttpServletRequest request,
      HttpServletResponse response,
      FilterChain filterChain) throws ServletException, IOException {

    try {
      // 1. 쿠키에서 Access Token 읽기
      String accessToken = cookieHelper.getAccessTokenFromCookie(request);

      // 2. 토큰 검증
      if (accessToken != null && jwtHelper.validateToken(accessToken, "access")) {
        // 3. 사용자 정보 추출
        Long userNo = jwtHelper.getUserIdFromToken(accessToken);
        String userEml = jwtHelper.getEmailFromToken(accessToken);
        String userRole = jwtHelper.getRoleFromToken(accessToken);

        if (userNo != null && userEml != null) {
          // 4. 권한 설정
          ArrayList<SimpleGrantedAuthority> authorities = new ArrayList<>();
          if (userRole != null) {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + userRole));
          }

          // 5. Authentication 객체 생성
          UsernamePasswordAuthenticationToken authentication = 
              new UsernamePasswordAuthenticationToken(
                  userNo,  // principal (사용자 번호)
                  null,    // credentials
                  authorities);

          authentication.setDetails(
              new WebAuthenticationDetailsSource().buildDetails(request));

          // 6. SecurityContext에 인증 정보 설정
          SecurityContextHolder.getContext().setAuthentication(authentication);
        }
      }
    } catch (Exception e) {
      log.error("JWT 인증 처리 중 오류 발생", e);
      // 인증 실패 시에도 요청은 계속 진행
    }

    // 7. 다음 필터로 요청 전달
    filterChain.doFilter(request, response);
  }
}
```

### 어노테이션 설명

#### `extends OncePerRequestFilter`
- **역할**: Spring Security의 필터 클래스
- **특징**: 한 요청당 한 번만 실행됨
- **왜 사용하나요?**: 필터 체인에서 중복 실행을 방지

### 동작 과정

1. **쿠키에서 토큰 읽기**: HTTP 요청의 쿠키에서 Access Token 추출
2. **토큰 검증**: 토큰이 유효한지 확인 (만료, 서명 등)
3. **사용자 정보 추출**: 토큰에서 사용자 번호, 이메일, 역할 추출
4. **권한 설정**: 사용자 역할을 Spring Security의 `GrantedAuthority`로 변환
5. **Authentication 객체 생성**: 인증 정보를 담은 객체 생성
6. **SecurityContext에 설정**: 현재 요청의 인증 정보를 저장
   - **효과**: 컨트롤러에서 `SecurityContextHolder.getContext().getAuthentication()`으로 현재 사용자 정보를 가져올 수 있음
7. **다음 필터로 전달**: 필터 체인을 계속 진행

### SecurityContext란?

Spring Security에서 현재 요청의 인증 정보를 저장하는 컨텍스트입니다.

**사용 예시**:
```java
// 컨트롤러에서 현재 사용자 번호 가져오기
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
Long userNo = (Long) authentication.getPrincipal();
```

---

## SecurityConfig - 보안 설정

Spring Security의 전역 보안 설정을 담당하는 클래스입니다.

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

  private final JwtAuthenticationFilter jwtAuthenticationFilter;

  @Bean
  public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }

  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable())  // CSRF 보호 비활성화 (JWT 사용 시)
        .authorizeHttpRequests(auth -> auth
            // Public 엔드포인트 (인증 불필요)
            .requestMatchers("/auth/signin", "/auth/signup", 
                           "/auth/refresh", "/auth/forgot-password", 
                           "/auth/reset-password")
            .permitAll()
            // Swagger UI
            .requestMatchers("/swagger-ui/**", "/swagger-ui.html", 
                           "/docs/**", "/v3/api-docs/**")
            .permitAll()
            // 나머지 모든 요청은 인증 필요
            .anyRequest().authenticated())
        .sessionManagement(session -> 
            session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .addFilterBefore(jwtAuthenticationFilter, 
            UsernamePasswordAuthenticationFilter.class);

    return http.build();
  }
}
```

### 어노테이션 설명

#### `@Configuration`
- **역할**: 이 클래스가 Spring 설정 클래스임을 나타냅니다
- **효과**: Spring이 이 클래스의 `@Bean` 메서드를 실행하여 빈을 등록합니다

#### `@EnableWebSecurity`
- **역할**: Spring Security를 활성화합니다
- **효과**: 보안 필터 체인이 적용됩니다

### 주요 설정 설명

#### CSRF 보호 비활성화
```java
.csrf(csrf -> csrf.disable())
```
- **이유**: JWT 토큰을 사용하므로 CSRF 공격에 안전합니다
- **CSRF란?**: Cross-Site Request Forgery, 다른 사이트에서 요청을 위조하는 공격

#### Public 엔드포인트 설정
```java
.requestMatchers("/auth/signin", "/auth/signup", ...)
.permitAll()
```
- **역할**: 인증 없이 접근 가능한 엔드포인트 지정
- **예시**: 로그인, 회원가입은 인증이 필요 없음

#### 인증 필요 설정
```java
.anyRequest().authenticated()
```
- **역할**: 위에서 지정하지 않은 모든 요청은 인증이 필요함
- **효과**: JWT 토큰이 없으면 401 Unauthorized 응답

#### Stateless 세션
```java
.sessionManagement(session -> 
    session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
```
- **역할**: 세션을 생성하지 않음
- **이유**: JWT 토큰만으로 인증하므로 서버에 세션을 저장할 필요가 없음

#### JWT 필터 추가
```java
.addFilterBefore(jwtAuthenticationFilter, 
    UsernamePasswordAuthenticationFilter.class)
```
- **역할**: JWT 인증 필터를 Spring Security 필터 체인에 추가
- **위치**: 기본 인증 필터(`UsernamePasswordAuthenticationFilter`) 전에 실행
- **효과**: 모든 요청이 컨트롤러에 도달하기 전에 JWT 토큰을 검증

---

## 전체 인증 흐름

### 로그인 흐름

```
1. 클라이언트 요청
   POST /auth/signin
   {
     "userEml": "test@example.com",
     "password": "Password123!"
   }

2. AuthController
   - @PostMapping으로 요청 받음
   - authService.signin(userVO, clientIp) 호출

3. AuthService
   - 사용자 조회 및 비밀번호 검증
   - JWT 토큰 생성 (Access Token, Refresh Token)
   - Refresh Token을 데이터베이스에 저장
   - 결과 반환

4. AuthController
   - 토큰을 쿠키에 설정
   - 사용자 정보 반환

5. 클라이언트 응답
   - 쿠키: access_token, refresh_token
   - 본문: 사용자 정보
```

### 인증된 API 요청 흐름

```
1. 클라이언트 요청
   GET /users/me
   쿠키: access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

2. JwtAuthenticationFilter
   - 쿠키에서 Access Token 읽기
   - 토큰 검증
   - 사용자 정보 추출
   - SecurityContext에 인증 정보 설정

3. SecurityConfig
   - 인증이 필요한 엔드포인트인지 확인
   - 인증 정보가 있으면 통과

4. UserController
   - SecurityContext에서 현재 사용자 번호 가져오기
   - userService.findUserById(userNo) 호출

5. UserService
   - 사용자 조회 및 반환

6. 클라이언트 응답
   {
     "data": {
       "userNo": 1,
       "userEml": "test@example.com",
       ...
     }
   }
```

### 토큰 갱신 흐름

```
1. 클라이언트 요청
   POST /auth/refresh
   쿠키: refresh_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

2. AuthController
   - 쿠키에서 Refresh Token 읽기
   - authService.refresh(refreshToken) 호출

3. AuthService
   - Refresh Token 검증
   - 데이터베이스의 Refresh Token과 일치 확인
   - 새 Access Token과 Refresh Token 생성
   - 새 Refresh Token을 데이터베이스에 저장

4. AuthController
   - 새 토큰을 쿠키에 설정
   - 토큰 정보 반환

5. 클라이언트 응답
   - 새 access_token, refresh_token 쿠키
```

---

## 다음 단계

이제 인증 시스템을 이해했으니, **공통 응답 구조와 예외 처리**에 대해 알아보겠습니다.

[다음: 05. 공통 응답 구조와 예외 처리](./05_공통_응답_구조와_예외_처리.md)
