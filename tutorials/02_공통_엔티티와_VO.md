# 02. 공통 엔티티와 VO 이해하기

## 목차
1. [Entity와 VO란?](#entity와-vo란)
2. [CommonEntity 이해하기](#commonentity-이해하기)
3. [CommonVO 이해하기](#commonvo-이해하기)
4. [Entity와 VO의 관계](#entity와-vo의-관계)

---

## Entity와 VO란?

### Entity (엔티티)
- **정의**: 데이터베이스 테이블과 직접 매핑되는 클래스
- **역할**: 데이터베이스에 저장될 실제 데이터의 구조를 정의
- **특징**: 
  - JPA 어노테이션을 사용하여 테이블과 매핑
  - 데이터베이스와 직접 소통

### VO (Value Object, 값 객체)
- **정의**: 데이터를 전달하기 위한 객체
- **역할**: 
  - 클라이언트와 서버 간 데이터 전달 (API 요청/응답)
  - 비즈니스 로직에서 데이터 처리
- **특징**: 
  - 데이터베이스와 직접 연결되지 않음
  - Entity와 변환하여 사용

### 왜 분리하나요?
1. **보안**: Entity에는 민감한 정보가 있을 수 있으므로, 필요한 정보만 VO로 전달
2. **유연성**: Entity 구조를 변경해도 API 응답 구조(VO)는 독립적으로 관리 가능
3. **명확성**: 각 레이어의 책임이 명확해짐

---

## CommonEntity 이해하기

모든 엔티티가 공통으로 가지는 필드들을 정의한 추상 클래스입니다.

```java
@Getter
@Setter
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class CommonEntity {
  
  @Column(name = "use_yn", length = 1)
  @ColumnDefault("'Y'")
  protected String useYn = "Y";

  @Column(name = "shrn_yn", length = 1)
  @ColumnDefault("'N'")
  protected String shrnYn = "N";

  @Column(name = "del_yn", length = 1)
  @ColumnDefault("'N'")
  protected String delYn = "N";

  @Column(name = "crt_no")
  protected Long crtNo;

  @Column(name = "crt_dt", updatable = false)
  @CreatedDate
  protected LocalDateTime crtDt;

  @Column(name = "updt_no")
  protected Long updtNo;

  @Column(name = "updt_dt")
  @LastModifiedDate
  protected LocalDateTime updtDt;

  @Column(name = "del_no")
  protected Long delNo;

  @Column(name = "del_dt")
  protected LocalDateTime delDt;

  // 소프트 삭제 메서드
  public void delete(Long deleterNo) {
    this.useYn = "N";
    this.delYn = "Y";
    this.delNo = deleterNo;
    this.delDt = LocalDateTime.now();
    this.updtNo = deleterNo;
    this.updtDt = LocalDateTime.now();
  }
}
```

### 어노테이션 설명

#### `@MappedSuperclass`
- **역할**: 이 클래스 자체는 테이블이 아니지만, 상속받는 클래스의 테이블에 필드를 추가
- **왜 사용하나요?**: 모든 엔티티에 공통 필드를 자동으로 포함시킬 수 있습니다
- **예시**: `UserEntity extends CommonEntity`를 하면 `users` 테이블에 `use_yn`, `del_yn` 등의 컬럼이 자동으로 포함됩니다

#### `@EntityListeners(AuditingEntityListener.class)`
- **역할**: 엔티티의 생명주기 이벤트를 감지하여 자동으로 처리
- **무엇을 하나요?**: 
  - 엔티티가 저장될 때 `@CreatedDate`가 붙은 필드에 현재 시간 자동 설정
  - 엔티티가 수정될 때 `@LastModifiedDate`가 붙은 필드에 현재 시간 자동 업데이트
- **왜 사용하나요?**: 매번 수동으로 날짜를 설정하는 번거로움을 없앨 수 있습니다

#### `@CreatedDate`
- **역할**: 엔티티가 처음 생성될 때 자동으로 현재 시간을 설정
- **사용 위치**: `crtDt` (생성 일시)
- **동작**: `userRepository.save(newUser)`를 호출하면 자동으로 현재 시간이 저장됩니다

#### `@LastModifiedDate`
- **역할**: 엔티티가 수정될 때마다 자동으로 현재 시간을 업데이트
- **사용 위치**: `updtDt` (수정 일시)
- **동작**: 엔티티를 수정하고 `save()`를 호출하면 자동으로 업데이트됩니다

#### `@ColumnDefault("'Y'")`
- **역할**: 데이터베이스 테이블 생성 시 기본값 설정
- **예시**: `use_yn` 컬럼의 기본값을 `'Y'`로 설정
- **주의**: Java 코드에서도 기본값을 설정해야 합니다 (`protected String useYn = "Y"`)

#### `@Getter`, `@Setter`
- **역할**: Lombok이 자동으로 getter/setter 메서드를 생성
- **왜 사용하나요?**: 반복적인 코드 작성을 줄일 수 있습니다

### 공통 필드 설명

#### 상태 관리 필드
- **`useYn`**: 사용 여부 (`Y`: 사용, `N`: 미사용)
- **`shrnYn`**: 공유 여부 (`Y`: 공유, `N`: 비공개)
- **`delYn`**: 삭제 여부 (`Y`: 삭제됨, `N`: 정상)

#### 감사(Audit) 필드
- **`crtNo`**: 생성자 번호 (누가 만들었는지)
- **`crtDt`**: 생성 일시 (언제 만들었는지) - 자동 설정
- **`updtNo`**: 수정자 번호 (누가 수정했는지)
- **`updtDt`**: 수정 일시 (언제 수정했는지) - 자동 업데이트
- **`delNo`**: 삭제자 번호
- **`delDt`**: 삭제 일시

### 소프트 삭제 (Soft Delete)

```java
public void delete(Long deleterNo) {
  this.useYn = "N";
  this.delYn = "Y";
  this.delNo = deleterNo;
  this.delDt = LocalDateTime.now();
  this.updtNo = deleterNo;
  this.updtDt = LocalDateTime.now();
}
```

- **하드 삭제 vs 소프트 삭제**:
  - **하드 삭제**: 데이터베이스에서 실제로 레코드를 삭제 (`DELETE FROM users WHERE ...`)
  - **소프트 삭제**: 레코드는 남겨두고 `del_yn` 플래그만 `'Y'`로 변경
- **왜 소프트 삭제를 사용하나요?**:
  1. 데이터 복구 가능
  2. 삭제 이력 추적 가능
  3. 참조 무결성 유지 (다른 테이블에서 참조하는 경우)

---

## CommonVO 이해하기

모든 VO가 공통으로 가지는 필드들을 정의한 클래스입니다.

```java
@Data
@NoArgsConstructor
public class CommonVO {

  protected String useYn;
  protected String shrnYn;
  protected String delYn;
  protected Long crtNo;
  protected LocalDateTime crtDt;
  protected Long updtNo;
  protected LocalDateTime updtDt;
  protected Long delNo;
  protected LocalDateTime delDt;

}
```

### 어노테이션 설명

#### `@Data`
- **역할**: Lombok이 자동으로 다음을 생성:
  - `@Getter`: 모든 필드의 getter 메서드
  - `@Setter`: 모든 필드의 setter 메서드
  - `@ToString`: toString() 메서드
  - `@EqualsAndHashCode`: equals()와 hashCode() 메서드
- **왜 사용하나요?**: 반복적인 코드를 자동으로 생성해줍니다

#### `@NoArgsConstructor`
- **역할**: 파라미터가 없는 기본 생성자를 자동 생성
- **왜 필요한가요?**: JSON 역직렬화나 리플렉션에서 객체를 생성할 때 필요합니다

### CommonEntity와의 관계

- **CommonEntity**: 데이터베이스와 직접 연결되는 필드들
- **CommonVO**: API 요청/응답에 사용되는 필드들
- **공통점**: 같은 의미의 필드들을 가지고 있음 (예: `useYn`, `delYn` 등)

---

## Entity와 VO의 관계

### 변환 과정

```
[클라이언트 요청]
    ↓
[VO] (UserVO)
    ↓ (toEntity())
[Entity] (UserEntity)
    ↓ (save())
[데이터베이스]
    ↓
[Entity] (UserEntity)
    ↓ (생성자: new UserVO(entity))
[VO] (UserVO)
    ↓
[클라이언트 응답]
```

### 실제 예시: UserVO

#### Entity → VO 변환 (조회 시)

```java
// UserVO.java
public UserVO(UserEntity userEntity) {
  this.mapFromEntity(userEntity);
}

private void mapFromEntity(UserEntity userEntity) {
  this.userNo = userEntity.getUserNo();
  this.userEml = userEntity.getUserEml();
  this.userNm = userEntity.getUserNm();
  // ... 나머지 필드들
}
```

- **언제 사용하나요?**: 데이터베이스에서 조회한 Entity를 API 응답으로 변환할 때
- **예시**: `UserService.findUserById()`에서 Entity를 조회한 후 VO로 변환하여 반환

#### VO → Entity 변환 (저장 시)

```java
// UserVO.java
public UserEntity toEntity() {
  return UserEntity.builder()
      .userEml(this.userEml)
      .userNm(this.userNm)
      .enpswd(this.enpswd)
      // ... 나머지 필드들
      .build();
}
```

- **언제 사용하나요?**: 클라이언트가 보낸 요청 데이터(VO)를 Entity로 변환하여 저장할 때
- **예시**: `UserService.createUser()`에서 VO를 받아 Entity로 변환 후 저장

### 왜 이렇게 복잡하게 하나요?

1. **보안**: Entity에는 비밀번호(`enpswd`) 같은 민감한 정보가 있지만, VO로 변환할 때는 제외할 수 있습니다
2. **유연성**: API 응답 구조를 Entity 구조와 독립적으로 변경할 수 있습니다
3. **명확성**: 각 레이어의 책임이 명확해집니다
   - **Controller**: VO를 받고 반환
   - **Service**: VO와 Entity를 변환하며 비즈니스 로직 처리
   - **Repository**: Entity만 다룸

---

## 다음 단계

이제 공통 구조를 이해했으니, 실제로 **사용자 관리 기능**이 어떻게 구현되었는지 살펴보겠습니다.

[다음: 03. 사용자 관리 기능 구현하기](./03_사용자_관리_기능_구현하기.md)
